module Advent2016_2 
    (   firstAnswer
    --,   secondAnswer
    ) where

newtype KeyPosition = P Int deriving(Show, Eq, Ord)

instance Bounded KeyPosition where
    minBound = P 0
    maxBound = P 2

instance Semigroup KeyPosition where
    P a <> P b = P (a + b)

instance Monoid KeyPosition where
    mempty = P 0    

data KeypadButton = K { xpos :: KeyPosition, ypos :: KeyPosition } deriving (Ord, Eq, Bounded)

instance Show KeypadButton where
    show (K (P 0) (P 0)) = "1"
    show (K (P 1) (P 0)) = "2"
    show (K (P 2) (P 0)) = "3"
    show (K (P 0) (P 1)) = "4"
    show (K (P 1) (P 1)) = "5"
    show (K (P 2) (P 1)) = "6"
    show (K (P 0) (P 2)) = "7"
    show (K (P 1) (P 2)) = "8"
    show (K (P 2) (P 2)) = "9"

class KeyMove a where
    up :: a -> a
    left :: a -> a
    down :: a -> a
    right :: a -> a

instance KeyMove KeypadButton where
    up k
        | (ypos k) == (minBound :: KeyPosition) = k
        | otherwise = k { ypos = (ypos k) <> (P (-1)) }
    left k
        | (xpos k) == (minBound :: KeyPosition) = k
        | otherwise = k { xpos = (xpos k) <> (P (-1)) }
    down k
        | (ypos k) == (maxBound :: KeyPosition) = k
        | otherwise = k { ypos = (ypos k) <> (P 1) }
    right k
        | (xpos k) == (maxBound :: KeyPosition) = k
        | otherwise = k { xpos = (xpos k) <> (P 1) }

data Move = None | U | L | D | R deriving(Show, Enum, Eq)

class ParseMove a where
    readMove :: Char -> a
    readMoves :: String -> [a]

instance ParseMove Move where
    readMove 'U' = U
    readMove 'L' = L
    readMove 'D' = D
    readMove 'R' = R
    readMoves str = map readMove str

initialButton = K (P 1) (P 1) -- "5"  
    
moveButton :: KeypadButton -> Move -> KeypadButton
moveButton kb U = up kb
moveButton kb L = left kb
moveButton kb D = down kb
moveButton kb R = right kb

moveButtons :: KeypadButton -> [Move] -> KeypadButton
moveButtons key ms = foldl moveButton key ms

    
buttons = 
    [   "UUURRRRULRDLRDRRDURDDDLLDLLLULDUDDLDLULUURULRLDLRRLLLRRDRRLDDLLULUDUDDLRDRDUURDLURUURLRULLDDURULRRURDUURLULUUUURDDDDUUDLULRULLLRLLRRRURDLLRLLRRRUURULRDRUUDDDDDLLLRURRURRUURDUURDDRDLULRRLLLDRRRLURRLLURLDRRDDLDLRRLLRDRLLLLDLULDLRRDRRLDDURLULLUDLUDRRDRRLRLULURDRLRLUUUDLRLDLLLURDUDULULDDRUUURLLLDLLDDUDDRURURUDDLUULRDRRRRLDRDDURLUDURDULLDLUDLULDRLRLLRLLLLRURDURLLDRRDRLRUUUUULLLRUDURUDLLLUDLLLLRDLDRDUDRURLUDDUDDURLUUUUDDLLUDLULLLLLDUDLLRLRRDDDULULRLDRLLULDLUDLLURULRDDUURULRDLDLDLRL"
    ,   "URUUURDULUDLUUUUDDRRRDRRRLDUDLRDRRDRDDLRUULDLLDUDULLLRLDRDRRLDLDLUUDRUULDUDULDUDURURDDURULDLURULRLULDUDDUULDLLLDDURDDRDDURUULUUDRLDDULDRRRRDURRUDLLLURDDDLRULLRDDRDDDDLUUDRDUULRRRRURULDDDLDDRDRRUDRRURUDRDDLDRRRLLURURUULUUDRDULLDRLRDRRDDURDUDLDRLUDRURDURURULDUUURDUULRRRRRUDLLULDDDRLULDDULUDRRRDDRUDRRDLDLRUULLLLRRDRRLUDRUULRDUDRDRRRDDRLLRUUDRLLLUDUDLULUUDULDRRRRDDRURULDULLURDLLLDUUDLLUDRLDURRRLDDDURUDUDURRULDD"
    ,   "LRUDDULLLULRLUDUDUDRLLUUUULLUDLUUUUDULLUURDLLRDUDLRUDRUDDURURRURUDLLLRLDLUDRRRRRRDLUURLRDDDULRRUDRULRDRDDUULRDDLDULDRRRDDLURRURLLLRURDULLRUUUDDUDUURLRLDDUURLRDRRLURLDRLLUUURDRUUDUUUDRLURUUUDLDRRLRLLRRUURULLLRLLDLLLDULDDLDULDLDDRUDURDDURDUDURDLLLRRDDLULLLUDURLUDDLDLUUDRDRUDUUDLLDDLLLLDRDULRDLDULLRUDDUULDUDLDDDRUURLDRRLURRDDRUUDRUDLLDLULLULUDUDURDDRLRDLRLDRLDDRULLLRUDULDRLRLRULLRLLRRRLLRRRDDRULRUURRLLLRULDLUDRRDDLLLUDDUDDDLURLUDRDLURUUDLLDLULURRLLDURUDDDDRLULRDDLRLDDLRLLDDRRLRDUDUUULRRLRULUDURDUDRLRLRUDUDLLRRRRLRRUDUL"
    ,   "RULLLLUUUDLLDLLRULLRURRULDDRDLUULDRLLRUDLLRRLRDURLLDUUUUURUUURDLUURRLDDDLRRRRLRULDUDDLURDRRUUDLRRRDLDDUDUDDRUDURURLDULLDLULDLLUDLULRDRLLURRLLDURLDLRDLULUDDULDLDDDDDUURRDRURLDLDULLURDLLDDLLUDLDLDRLRLDLRDRLDLRRUUDRURLUUUDLURUULDUDRDULLDURUDLUUURRRLLDUDUDDUUULLLRUULDLURUDDRLUDRDDLDLLUDUDRRRDDUUULUULLLRLLUURDUUDRUUULULLDLDRUUDURLLUULRLDLUURLLUUDRURDDRLURULDUDUUDRRUUURDULRLDUUDDRURURDRRULDDDRLUDLLUUDURRRLDLRLRDRURLURLLLRLDDLRRLDLDDURDUUDRDRRLDRLULDRLURUUUDDRLLLDDLDURLLLLDRDLDRRUDULURRLULRDRLLUULLRLRDRLLULUURRUDRUDDDLLDURURLURRRDLLDRDLUDRULULULRLDLRRRUUDLULDURLRDRLULRUUURRDDLRUURUDRURUDURURDD"
    ,   "DURRDLLLDDLLDLLRLULULLRDLDRRDDRDLRULURRDUUDDRLLDDLDRRLRDUDRULDLRURDUUDRDDLLDRRDRUDUDULLDDDDLDRRRLRLRDRDLURRDDLDDDUUDRDRLLLDLUDDDLUULRDRLLLRLLUULUDDDRLDUUUURULRDDURRDRLUURLUDRLRLLLDDLRDDUULRRRRURDLDDDRLDLDRRLLDRDDUDDUURDLDUUDRDLDLDDULULUDDLRDDRLRLDDLUDLLDRLUDUDDRULLRLDLLRULRUURDDRDRDRURDRRLRDLLUDDRRDRRLDDULLLDLUDRRUDLDULDRURRDURLURRLDLRDLRUDLULUDDRULRLLDUURULURULURRLURRUULRULRRRLRDLULRLRLUDURDDRUUURDRLLRRRDDLDRRRULLDLRDRULDRRLRRDLUDDRDDDUUURRLULLDRRUULULLRRRRLDDRDDLUURLLUDLLDUDLULUULUDLLUUURRRUDDDRLLLRDRUUDUUURDRULURRLRDLLUURLRDURULDRRUDURRDDLDRLDRUUDRLLUDLRRU"
    ]
    
moves = map (\x -> readMoves x :: [Move]) buttons

getKeys kb (m:[]) = [moveButtons kb m]
getKeys kb (m:ms) = moveButtons kb m : getKeys (moveButtons kb m) ms 

firstAnswer = getKeys initialButton moves

data DiamondPosition = D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9 | DA | DB | DC | DD deriving(Eq, Show, Ord)
data DiamondNeighbourgood = N (DiamondPosition, [DiamondPosition])
    
--func = N [L]

